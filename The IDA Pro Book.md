# 第一部分  IDA简介

## 第1章 反汇编简介

* 反汇编理论
  * 第一代语言：0和1、机器语言、字节码。机器语言程序常被称为二进制文件
  * 第二代语言：汇编语言，助记符与具体的位模式或操作码联系起来。汇编器将汇编语言程序转换成能够执行的机器语言
  * 第三代语言：引入关键字和结构，不依赖任何平台。常使用编译器转换成汇编语言或直接转换为机器语言（或大致等价的形式，如字节码）
  * 第四代语言：存在，但无关，不讨论
  
* 何为反汇编
  * 撤销汇编和编译过程：反汇编器、反编译器（直接输出高级语言）
  * 反汇编的困难
    * 编译过程会造成损失：机器语言中没有变量或函数名
    * 编译属于多对多操作：源程序与汇编语言间是多对多关系
    * 反编译器非常依赖于语言和库：用对Windows编程API一无所知的反编译器处理编译后的Windows二进制文件不会得到任何有用的结果
    * 想要准确地反编译一个二进制文件，需要近乎完美的反汇编能力：反汇编阶段的任何错误或遗漏都会影响反编译代码
  
* 为何反汇编
  * 分析恶意软件
    * 动态分析和静态分析是分析恶意软件的两种主要技术
    * **动态分析**：在严格控制的环境（沙盒）中执行恶意软件，并使用系统检测实用工具记录其所有行为
    * **静态分析**：通过浏览程序代码来理解程序的行为，此时要查看的就是对恶意软件进行反汇编之后的代码清单
  * 分析闭源软件的漏洞
  * 分析闭源软件的互操作性
  * 分析编译器生成的代码，以验证编译器的性能和准确性
  * 在调试时显示程序指令
  
* 如何反汇编、

  * 基本的反汇编算法

    1. 确定进行反汇编的代码区域

       | 操作系统 | 可执行文件格式                     |
       | -------- | ---------------------------------- |
       | Windows  | Portable Executable, PE            |
       | Unix     | Executable and linking format, ELF |

    2. 知道起始地址后，读取该地址（或文件偏移量）所包含的值，并执行表查找，将二进制操作码与其汇编语言助记符对应起来

    3. 对汇编语言等价形式进行格式化，并将其在反汇编代码中输出。多种汇编语言输出格式可供选择：如，X86汇编语言所使用的两种主要格式为Intel格式和AT&T格式

       | 汇编语言格式 | 特点                                                         |
       | ------------ | ------------------------------------------------------------ |
       | AT&T         | %作为寄存器名称前缀，$作为文字常量（立即数）的前缀，源操作数在左边，目的操作数在右边：`add $0x4, %eax`, GUN汇编器和其它GNU工具（gcc、gdb）都使用AT&T语法 |
       | Intel        | 不需要寄存器和文字前缀，操作数排序方式与AT&T恰相反：`add eax, 0x4`, 微软汇编器MASM、Borland的Turbo汇编器TASM和Netwide汇编器NASM使用 |

    4. 输出一条指令后，继续反汇编下一条指令，并重复上述过程，直到反汇编完全文件中的所有指令

  * 大量算法可用于确定何处开始反汇编，如何选择下一条反汇编指令，如何确定代码与数据，以及如何确定何时完成最后一条指令的反汇编。**线性扫描**和**递归下降**是两种最主要的反汇编算法

  * **线性扫描反汇编**

    * 能够完全覆盖程序的所有代码段，但没有考虑到代码中可能混有数据

  * **递归下降反汇编**

    * 强调控制流的概念，控制流根据一条指令是否被另一条指令引用来决定是否对其进行反汇编
    * 控制流
      * 顺序流指令
      * 条件分支指令
      * 无条件分支指令
      * 函数调用指令
      * 返回指令
    * 具有区分代码与数据的强大能力
    * 无法处理间接代码路径，如利用指针表来查找目标地址的跳转或调用。然而，通过采用一些用于识别指向代码的指针的启发（heuristics）式方法可以解决。
    * IDA Pro是一种最为典型的递归下降反汇编器，**了解递归下降过程**有助于我们**识别IDA无法进行最佳反汇编的情形**，以及**制定策略来改进IDA的输出结果**。

## 第2章 逆向与反汇编工具

* 分类工具

  * 绝不要根据文件的扩展名来确定文件的类型

  * 不要完全相信任何工具所提供的结果

  * **file**

    * 大多*NIX风格操作系统和Windows下的Cygwin或MinGw工具都带有

    * 通过检查文件中的某些特定字段来确认文件类型：常见字符串`#!bin/sh`或`<html>`

    * 对于非ASCII内容的文件困难一些，这时会设法判断该文件是否符合某种已知的文件格式：多数情况下会搜索某些文件类型所特有的标签值（通常称为**幻数**）

    * 幻数文件（magic file）默认位置因操作系统而异：`/usr/share/file/magic`, `/usr/share/misc/magic`, `/etc/magic`

    * > 去除二进制可执行文件的符号

  * PE Tools

    * > 二进制文件模糊技术obfuscation

    * 分析Windows系统中正在运行的进程和可执行文件

    * https://down.52pojie.cn/Tools/PEtools/

  * PEiD

    * 识别构建某一特定Windows PE二进制文件所使用的编译器，
    * 并确定任何用于模糊Windows PE二进制文件的工具
    * 许多其它功能与PE Tools相同，包括显示PE文件头信息摘要、收集有关正在运行的进程的信息、执行基本的反汇编等

* 摘要工具

  * 在对文件初步分类后，需要用更高级的工具来提取详尽的信息

  * nm

    * 除非被告知要去除最终的可执行文件中的符号，否则，连接器通常会将目标文件的符号带入最终的可执行文件中
    * nm工具的作用是列举目标文件中的符号
    * nm检查中间目标文件时（扩展名为.o的文件，而非可执行文件），默认输出结果是在这个文件中声明的任何函数和全局变量的名称
    * 使用nm列举可执行文件的符号，将会有更多的信息显示出来
    * 动态链接二进制文件，未定义的符号将在C语言共享库中定义

  * ldd(list dynamic dependencies)

    * 创建可执行文件时，必须解析该文件引用的任何库函数的地址。两种方法解析对库函数的调用，连接器的命令行参数决定具体使用哪一种方法。

      1. 静态链接
         * 链接器会将应用程序的目标文件和所需的库文件组合起来，生成一个可执行文件，运行时无需确定库代码的位置
         * 函数调用更快，发布二进制文件更容易
         * 生成可执行文件更大，如果库组件发生改变，对程序进行升级会更加困难
      2. 动态链接
         * 链接器不需要复制它需要的任何库，只需要对所需库（通常为.so或.dll文件）的引用插入到最终的可执行文件中。
         * 生成的可执行文件更小一些，升级库代码简单多了--因为只需要维护一个库（被许多二进制文件引用）
         * 需要更加复杂的加载过程；供应商不仅需要发布他们自己的可执行文件，而且必须发布该文件所需的所有库文件

      * 一个可执行文件可能为静态链接、动态链接，或者二者兼有之
      * 与静态链接二进制文件不同，我们可以轻易确定一个动态链接二进制文件所依赖的库文件

  * objdump

    * 功能非常多样，显示与目标文件有关的信息，主要有
      * 节头部：程序文件每节的摘要信息
      * 专用头部：程序内存分布信息，还有运行时加载器所需的其它信息，包括由ldd等工具生成的库列表
      * 调试信息：提取出程序文件中的任何调试信息
      * 符号信息：以类似nm的方式转储符号表信息
      * 反汇编代码清单：不太好，dead listing，线性扫描反汇编

  * readelf

  * otool

    * 可用于解析与OS X Mach-O二进制文件有关的信息，可简单将其描述为OS X系统下的类似于objdump的实用工具

  * dumpbin

    * `dumpbin /dependents calc.exe` 以类似于ldd的方式显示计算器程序的动态依赖关系
    * 是微软Visual Studio工具套件中的一个命令行实用工具
    * 与otool和objdump一样可以显示大量与Windows PE文件有关的信息

  * c++filt

    * 为支持重载，编译器将描述函数参数类型的信息合并到函数的原始名称中（改编 name mangling）
    * 需要一个能理解编译器名称改编方案的工具：c++filt正是这样的工具
    * 可以得到函数的原始名称

* 深度检测工具

  * strings
    * 字符串：可打印字符组成的连续字符序列（通常还需指定最小长度和一个特定的字符集）
    * 不受文件格式限制
    * strings默认设置：至少包含4个字符的7位ASCII序列
    * 注意事项
      * 在处理可执行文件时，默认情况下，strings仅仅扫描文件中可加载的、经初始化的部分，使用参数`-a`可强制扫描整个文件
      * 使用`-t`可令strings显示所发现的每一个字符串的文件偏移量信息
      * 使用`-e`可使strings搜索更广泛额字符，如16位的Unicode字符
  * 反汇编器
    * 有时遇到一些并不常用文件格式的二进制文件，需要一些能够从用户指定的偏移量开始反汇编过程的工具
    * 有两个用于x86指令集的**流式反汇编器**（stream disassembler）：ndisasm和diStorm
    * 由于流式反汇编非常灵活，所以用途相当广泛，如分析网络数据包中可能包含shellcode的计算机网络攻击

## 第3章 IDA Pro 背景知识

# 第二部分 IDA基本用法

## 第4章 IDA入门

## 第5章 IDA数据显示窗口

## 第6章 反汇编导航

## 第7章 反汇编操作

## 第8章 数据类型与数据交互

## 第9章 交叉引用与绘图功能

## 第10章 IDA的多种面孔